use proc_macro2::{
    TokenStream,
    TokenTree,
    Group,
    Ident,
    Span,
};
use quote::quote;

use venial::{
    Function,
    Declaration,
    Error,
};

type Result<T> = core::result::Result<T, Error>;

#[proc_macro_attribute]
pub fn wasm_test(
    _attr: proc_macro::TokenStream,
    stream: proc_macro::TokenStream
    ) -> proc_macro::TokenStream 
{
    match wasm_test_macro(stream.into()){
        Ok(t) => t.into(),
        Err(e) => e.to_compile_error().into()
    }
}

fn wasm_test_macro(content: TokenStream) 
     -> Result<TokenStream> {

    let declaration = venial::parse_declaration(content)?;

    if let Declaration::Function(f) = declaration  {
        let should_panic = has_should_panic(&f)?;
        let body = match f.body {
            Some(x) => x.stream(),
            None => return Err(Error::new("there is no function body to test"))
        };

        let name = f.name.to_string();

        Ok(generate_output(&name, should_panic, body))
    }

    else {
        return Err(Error::new("please provide a function"))
    }

}

/// `has_should_panic(f) returns
/// - true if `f` has the single attribute `#[should_panic]`
/// - false if `f` has no attributes
/// - an error in any other case
fn has_should_panic(f: &Function) -> Result<bool> {
    if f.attributes.len() == 0 {
        return Ok(false);
    }
    if f.attributes.len() > 1 {
        let last = f.attributes.last().unwrap();
        return Err(Error::new_at_span(
                f.attributes[0].tk_hash.span().join(last.tk_hash.span()).unwrap(),
                "the only attribute you can add here is `should_panic`"
                ))
    }

    if f.attributes[0].path.len() != 1
    || &f.attributes[0].path[0].to_string() != "should_panic" {
        return Err(Error::new_at_span(
                f.attributes[0].path[0].span(),
                "the only allowed attribute is `should_panic`"
                ))
    }

    let attr = &f.attributes[0];

    if attr.value.get_value_tokens().len() != 0 {
        return Err(Error::new("arguments given to `should_panic` are not supported"))
    }

    Ok(true)
}


/// `generate_output(name, should_panic, body)` returns the entire tokenStream
/// needed to run the test, once compiled by rust.
/// It exports functions that will be imported by the runner,
/// once compiled to webassembly
fn generate_output(name: &str, should_panic: bool, body: TokenStream) -> TokenStream {
    let generated_body = replace_print_calls_in_body(body);

    let generated_ident = Ident::new(
        &format!("__wasm_test_unit__{name}"),
        Span::call_site(),
    );

    let generated_metadata_ident = Ident::new(
        &format!("__wasm_test_meta__{name}"),
        Span::call_site(),
    );

    quote!{

        // automatically generated by wasm_test
        #[no_mangle]
        pub extern "C" fn #generated_ident () {
            #generated_body
        }

        // automatically generated by wasm_test
        #[no_mangle]
        pub extern "C" fn #generated_metadata_ident () -> i32 {
            use ::wasm_test::__runtime::{
                serde_json,
                Serialize,
                UnitMetadata
            };
            let meta = UnitMetadata {
                should_panic: #should_panic,
                path: module_path!().to_string(),
            };

            let mut s = serde_json::to_string(&meta).unwrap();
            // null-terminated string
            s.push('\0');
            return s.as_ptr() as i32
        }
    }
}



/// replace all `print!(...)` and `println!(...)` 
/// by special functions defined in `wasm-test`.
/// That way, the user don't have to care about the internals
fn replace_print_calls_in_body(s: TokenStream) -> TokenStream {
    enum ReadingState {
        Default,
        AfterPrint,
        AfterPrintln,
        AfterPrintMacro,
        AfterPrintlnMacro,
    }

    use ReadingState::*;

    let mut state = Default;

    let replace_print = |t: TokenTree| -> TokenStream {
        match (t, &state) {
            (TokenTree::Ident(x), Default) if x=="print" => {
                state = AfterPrint;
                quote!{}
            },
            (TokenTree::Ident(x), Default) if x=="println" => {
                state = AfterPrintln;
                quote!{}
            },
            (TokenTree::Punct(a), AfterPrint) if a.as_char()=='!' => {
                state = AfterPrintMacro;
                quote!{}
            },
            (TokenTree::Punct(a), AfterPrintln) if a.as_char()=='!' => {
                state = AfterPrintlnMacro;
                quote!{}
            }
            (TokenTree::Group(g), AfterPrintMacro) => {
                let content = g.stream();
                state = Default;
                quote!{
                    {
                    let string = format!( #content );
                    ::wasm_test::__runtime::print(string);
                    }
                }
            },
            (TokenTree::Group(g), AfterPrintlnMacro) => {
                let content = g.stream();
                state = Default;
                quote!{
                    {
                    let string = format!( #content );
                    ::wasm_test::__runtime::println(string);
                    }
                }
            },
            (TokenTree::Group(g), _) =>  
                 TokenTree::Group(
                    Group::new(g.delimiter(), replace_print_calls_in_body(g.stream()))
                ).into()
            ,
            (x, _) => quote!(#x),
        }
    };

    s.into_iter().flat_map(replace_print).collect()
}

